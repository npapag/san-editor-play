package converters
{
	import mx.controls.Alert;
	
	public class SanToRdfConverter
	{
		private var BNS:String = ":";
		private var _PREFIXES:String =  
			( <![CDATA[#Generated by ICCS SAN Editor
				
		@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
		@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . 
		@prefix san: <http://imu.ntua.gr/ontologies/san/2011/06/01/san.rdf#> . 
		@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
		]]> ).toString();
		
		public function SanToRdfConverter()
		{
		}
		
		
		public function getN3(san:XML):String {
			var n3:Object = {n3str:getPrefixes(san)}; //object are passed by ref !!!			
			var sans:XMLList  ;
			var apsans:XMLList  ;
			
			for each (var entity in san.entity) {
				getEntityN3(entity,n3);
				sans = (entity as XML).sans.san ;
				for each (var node:XML in sans) {
					getNodeN3(node,n3,null);
					trace(">>"+n3.n3str);
				}//each san				
				for each (var apool in entity.apool) {
					//action pools					
					getActionPoolN3(apool,n3);
					apsans = (apool as XML).sans.san ;
					for each (var node:XML in apsans) {
						getNodeN3(node,n3,null);
						trace(">>"+n3.n3str);
					}					
				}//each apool.san				
			}// each san.entity
			
			//Exports all metadata at the end ..
			getMetadataN3(san,n3);
			
			var result:String = n3.n3str;
			//Alert.show(result);
			return result; //res;
		}
		
		private function getActionPoolN3(apool,n3):void {
			n3.n3str += "\n# " + apool.localName() + ":"+ apool.@id + " \n";
			n3.n3str += triple(ID(apool.@id), "a","san:ActionPool",false);			
			for each (var san in apool.sans.san) {
				trace(san);
				try {
					trace(ID(san.g[0].@id));
					n3.n3str += prop("san:hasAction",ID(san.g[0].@id),false);
				} catch (e:Error) {}
			}
			n3.n3str += prop("san:name",stringLiteral(apool.@name),true);
		}
		
		private function getMetadataN3(san:XML,n3:Object):void {
			n3.n3str += "\n# --- Metadata --- \n";
			for each (var metadata:XML in san..meta) {
				var mparent:XML = metadata.parent();
				mparent.@id;
				n3.n3str += "\n# " + metadata.localName() + ":"+ metadata.@id + " \n";
				n3.n3str += triple(ID(mparent.@id), "san:hasMetadata",ID(metadata.@id),true);
				n3.n3str += triple(ID(metadata.@id), "a","san:Metadata",false);
				n3.n3str += prop("san:name",stringLiteral(metadata.@name),false);
				n3.n3str += prop("san:type",stringLiteral(metadata.@type),false);
				n3.n3str += prop("san:value",stringLiteral(metadata.@value),false);
				n3.n3str += prop("san:step",stringLiteral(metadata.@step),false);
				n3.n3str += prop("san:range",stringLiteral(metadata.@range),false);
				n3.n3str += prop("san:direction",stringLiteral(metadata.@direction),true);								
			}
		}
		
		private function getEntityN3(node:XML,n3:Object):void {
			n3.n3str += "\n# " + node.localName() + ":"+ node.@id + " \n";
			n3.n3str += triple(ID(node.@id), "a","san:SANEntity",false);
			for each (var san:XML in node.sans.san) {
				for each (var goal:XML in san.g) {
					if (goal.@type=="root")
						n3.n3str += prop("san:hasRootGoal",ID(goal.@id),false);	
				}
				
			}
			if (node.@auto_start == "true")				
				n3.n3str += prop("san:auto-start",stringLiteral("yes"),false);
			else
				n3.n3str += prop("san:auto-start",stringLiteral("no"),false);
			
			
			n3.n3str += prop("san:name",stringLiteral(node.@name),true);
		}
		
		private function getNodeN3(node:XML,n3:Object,parent:XML):void { //use object to pass by ref
			var children:XMLList;
			trace("--\n"+n3.n3str);
			if( node == null ) {
				trace("\nnull node\n");
				return;
			}
			if (parent!=null) trace("parent:" + parent.localName() );
			n3.n3str += "\n# " + node.localName() + ":"+ node.@id + " \n";
			trace("--\n"+n3.n3str);
			var lname:String = node.localName();
			switch (lname) {
				case "san":
					//n3.n3str += "\t  @prefix :\t<" + node.@base + ">\t.\n";
					//"\t@prefix : \<" + node.@base "\> .\n";
					break;
				case "g":
					var o:String = "san:Goal";
					if (parent!=null)
						if (parent.localName()=="san") o="san:RootGoal"; 
					n3.n3str += triple(ID(node.@id), "a",o,false);
					
					if (node.@autostart == "yes")				
						n3.n3str += prop("san:auto-start",stringLiteral("yes"),false);
					else
						n3.n3str += prop("san:auto-start",stringLiteral("no"),false);
					
					if (node.c[0] !=null)
						n3.n3str += prop("san:hasContextCondition",ID(node.c[0].@id),false);
					if (node.s[0] !=null)
						n3.n3str += prop("san:hasSituation",ID(node.s[0].@id),false);
					if (node.a[0] !=null)
						n3.n3str += prop("san:hasAction",ID(node.a[0].@id),false);
					if (node.d[0] !=null)
						n3.n3str += prop("san:hasAction",ID(node.d[0].@id),false); //Decorator
					n3.n3str += prop("san:name",stringLiteral(node.@name),true);	
					break;
				case "c":
					n3.n3str += triple(ID(node.@id), "a","san:ContextCondition",false);
					if (node.@dialect!=null)
						n3.n3str += prop("san:dialect",stringLiteral(node.@dialect),false);
					if (node.@definedBy!=null)
						n3.n3str += prop("san:defined-by",stringLiteral(node.@definedBy),false);
					n3.n3str += prop("san:name",stringLiteral(node.@name),true);
					break;
				case "s":
					var contextualizerURI:String =null;
					n3.n3str += triple(ID(node.@id), "a","san:Situation",false);
					if (node.@dialect!=null)
						n3.n3str += prop("san:dialect",stringLiteral(node.@dialect),false);
					if (node.@definedBy!=null)
						n3.n3str += prop("san:defined-by",stringLiteral(node.@definedBy),false);
					if (node.@ctxtype!=null) {
						contextualizerURI = node.@id+"_Ctxzr_"+node.@ctxtype;
						//create a contextualizer
						n3.n3str += prop("san:hasContextualizer",ID(contextualizerURI),false);
					}
					n3.n3str += prop("san:name",stringLiteral(node.@name),true);
					if (contextualizerURI!=null) {
						n3.n3str += "\n# Situation contextualizer - BEGIN\n";
						n3.n3str += triple(ID(contextualizerURI), "a","san:Contextualizer",false);						
						//for each node.ctxqry
						for each (var ctxqry in node.ctxqry) {
							n3.n3str += prop("san:contextualizer-query",ID(contextualizerURI+ctxqry.@id),false);	
						}
						n3.n3str += prop("san:type",stringLiteral(node.@ctxtype),true);
						for each (var ctxqry in node.ctxqry) {
							n3.n3str += "\n";
							n3.n3str += triple(ID(contextualizerURI+ctxqry.@id),"a","san:ContextualizerQuery",false);
							if (ctxqry.@language!=null)
								n3.n3str += prop("san:language",stringLiteral(ctxqry.@language),false);
							if (ctxqry.@context!=null)
								n3.n3str += prop("san:context",stringLiteral(ctxqry.@context),false);
							if (ctxqry.@dialect!=null)
								n3.n3str += prop("san:dialect",stringLiteral(ctxqry.@dialect),false);
							if (ctxqry.@dedfinedBy!=null)
								n3.n3str += prop("san:defined-by",stringLiteral("\n"+ctxqry.@definedBy+"\n"),true);
						}
						n3.n3str += "\n# Situation contextualizer - END\n";
					}
					break;
				case "a":
					//n3.n3str += triple(ID(node.@id), "a","san:Action",false);
					var seqstr:String = "";
					trace("** " + node.@id + " -> " + node.@type);
					//Alert.show("** " + node.@id + " -> " + node.@type);
					switch (String(node.@type)) {
						case "Primitive":
							n3.n3str += triple(ID(node.@id), "a","san:PrimitiveAction",false);
							n3.n3str += prop("san:command",stringLiteral(node.@command),false);
							
							n3.n3str += prop("san:dialect",stringLiteral(node.@dialect),false);							
							n3.n3str += prop("san:defined-by",stringLiteral(node.@definedBy),false);
							
							break;
						case "Abstract":
							n3.n3str += triple(ID(node.@id), "a","san:AbstractAction",false);
							n3.n3str += prop("san:action-pool",stringLiteral(node.@actionPool),false);
							n3.n3str += prop("san:selection-method",stringLiteral(node.@selectionMethod),false);
							n3.n3str += prop("san:resolution-policy",stringLiteral(node.@resolutionPolicy),false);
							break;
						case "Calculation":
							n3.n3str += triple(ID(node.@id), "a","san:CalculationAction",false);
							n3.n3str += prop("san:dialect",stringLiteral(node.@dialect),false);							
							n3.n3str += prop("san:defined-by",stringLiteral(node.@definedBy),false);
							break;
						case "Mount":
							n3.n3str += triple(ID(node.@id), "a","san:MountAction",false);
							n3.n3str += prop("san:mount-san",stringLiteral(node.@mountSAN),false);
							break;
						case "Sequence":
							n3.n3str += triple(ID(node.@id), "a","san:SequenceAction",false);							
							var first:Boolean = true;
							var prev_id:String = null;
							
							for each (var ch:XML in node.children()) {
							if (first) {
								//n3.n3str += triple(ID(node.@id), "san:hasAction",ID(ch.@id),false);
								n3.n3str += prop("san:hasAction",ID(ch.@id),false);									
								prev_id = ID(ch.@id);
								first = false;
							}
							else {
								seqstr += triple(prev_id, "san:nextAction",ID(ch.@id),true);
								//n3.n3str += prop("san:hasAction",ID(ch.@id),false);
								prev_id = ID(ch.@id);
							}
						}//for each
							n3.n3str += prop("san:selection-method",stringLiteral(node.@selectionMethod),false);
							break;
						case "Selector":
							n3.n3str += triple(ID(node.@id), "a","san:SelectorAction",false);
							var first:Boolean = true;
							var prev_id:String = null;
							for each (var ch:XML in node.children()) {
							if (first) {
								//n3.n3str += triple(ID(node.@id), "san:hasAction",ID(ch.@id),false);
								n3.n3str += prop("san:hasAction",ID(ch.@id),false);
								prev_id = ID(ch.@id);
								first = false;
							}
							else {
								//n3.n3str += triple(prev_id, "san:nextAction",ID(ch.@id),false);
								seqstr += triple(prev_id, "san:nextAction",ID(ch.@id),true);									
								prev_id = ID(ch.@id);
							}
						}//for each
							n3.n3str += prop("san:selection-method",stringLiteral(node.@selectionMethod),false);
							break;
						case "ParallelAny":
							n3.n3str += triple(ID(node.@id), "a","san:ParallelAnyAction",false);
							for each (var ch:XML in node.children()) {
							//n3.n3str += triple(ID(node.@id), "san:hasAction",ID(ch.@id),false);
							n3.n3str += prop("san:hasAction",ID(ch.@id),false);
						}
							break;
						case "ParallelAll":
							n3.n3str += triple(ID(node.@id), "a","san:ParallelAllAction",false);
							for each (var ch:XML in node.children()) {
							//n3.n3str += triple(ID(node.@id), "san:hasAction",ID(ch.@id),false);
							n3.n3str += prop("san:hasAction",ID(ch.@id),false);
						}
							break;
						default:
							n3.n3str += triple(ID(node.@id), "a","san:Action",false);
							break;
					}
					n3.n3str += prop("san:name",stringLiteral(node.@name),true);
					n3.n3str += "#action sequences \n" + seqstr;
					break;
				case "d":					
					switch (String(node.@type)) {
						case "Condition":
							n3.n3str += triple(ID(node.@id), "a","san:ConditionDecorator",false);
							n3.n3str += prop("san:condition-dialect",stringLiteral(node.@conditionConditionDialect),false);							
							n3.n3str += prop("san:condition-defined-by",stringLiteral(node.@definedBy),false);
							break;
						case "Loop":
							n3.n3str += triple(ID(node.@id), "a","san:LoopDecorator",false);
							n3.n3str += prop("san:loop-condition-dialect",stringLiteral(node.@loopConditionDialect),false);							
							n3.n3str += prop("san:loop-condition-defined-by",stringLiteral(node.@loopCondition),false);
							break;
						case "Counter":
							n3.n3str += triple(ID(node.@id), "a","san:CounterDecorator",false);
							n3.n3str += prop("san:counter-variable",stringLiteral(node.@counterVariable),false);
							n3.n3str += prop("san:counter-start",stringLiteral(node.@counterStart),false);
							n3.n3str += prop("san:counter-step",stringLiteral(node.@counterStep),false);
							break;
						case "Timer":
							n3.n3str += triple(ID(node.@id), "a","san:TimerDecorator",false);
							n3.n3str += prop("san:timeout",stringLiteral(node.@timeout),false);
							n3.n3str += prop("san:return-code",stringLiteral(node.@returnCode),false);
							break;
						case "Print":
							n3.n3str += triple(ID(node.@id), "a","san:PrintDecorator",false);
							n3.n3str += prop("san:message",stringLiteral(node.@message),false);
							break;
						case "Break":
							n3.n3str += triple(ID(node.@id), "a","san:BreakDecorator",false);
							n3.n3str += prop("san:message",stringLiteral(node.@message),false);
							break;
						case "Success":
							n3.n3str += triple(ID(node.@id), "a","san:SuccessDecorator",false);
							break;
						case "Failure":
							n3.n3str += triple(ID(node.@id), "a","san:FailureDecorator",false);
							break;
						case "ExceptionHandler":
							n3.n3str += triple(ID(node.@id), "a","san:Decorator",false);
							n3.n3str += prop("san:exception-type",stringLiteral(node.@exceptionType),false);
							n3.n3str += prop("san:failover-job",stringLiteral(node.@failoverJob),false);
							break;
						default:
							//n3.n3str += triple(ID(node.@id), "a","san:ExceptionHandlerDecorator",false);
							break;
					}
					for each (var ch:XML in node.children()) {
					//n3.n3str += triple(ID(node.@id), "san:hasAction",ID(ch.@id),false);
					n3.n3str += prop("san:hasAction",ID(ch.@id),false);
				}
					n3.n3str += prop("san:name",stringLiteral(node.@name),true);
					break;
			}
			
			try {
				children = XMLList(node.children());
				for(var i:Number=0; i < children.length(); i++) {
					//if( children[i].@id == node.@id ) {
					//n3str += children[i].localName() +"\n";
					getNodeN3(children[i],n3,node);
					//}
				}//for
			} catch (e:Error){
				trace(e);
			}
			
			trace("**\n"+n3.n3str);
			//if (children!=null) getNodeN3(children,n3str); 
		}
		
		private function ID(id:String):String {
			return this.BNS + encodeURIComponent(id);
		}
		private function stringLiteral(value:String):String {
			//escape n3 strings			 
			return "\""+ escapeN3(value) + "\"^^xsd:string" ;
		}
		//n3.n3str += triple(ID(node.@id), "a","san:Goal",false);
		private function triple(s:String,p:String,o:String,terminal:Boolean):String {
			var t:String;
			if (terminal) t="." else t=";";
			return s + "\t" + p + "\t" + o + " " + t + "\n";
		}
		//n3.n3str += prop("san:name",litstr(node@name),true);
		private function prop(p:String,o:String,terminal:Boolean):String {
			var t:String;
			if (terminal) t="." else t=";";
			return "\t\t" + p + "\t" + o + " " + t + "\n";
		}
		
		private function escapeN3(s:String):String
		{
			var newString:String =
				//this is for regex escape ?is it the same for n3 ?
				//s.replace( new RegExp("([{}\(\)\^$&.\*\?\/\+\|\[\\\\]|\]|\-)","g"),"\\$1");
				s..replace(/(["'\\])/g, "\\$1");
			
			//s.split('\"').join('\\"').split('\\').join('\\\\');//escapes " to \" and \ to \\
			
			return newString;
		}
		
		private function getPrefixes(san:XML):String {
			var myPrefices:String = "";
			for each (var prefix in san.global.prefix) {								
				myPrefices +=  "\t  @prefix "+prefix.@name+"\t<" + prefix.@value + ">\t.\n";
			}
			return this._PREFIXES + "\n" + myPrefices;
		}
	}
	
}